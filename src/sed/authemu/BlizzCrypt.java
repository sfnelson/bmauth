package sed.authemu;
import java.util.Random;

/**
 * Key generator.
 */
public final class BlizzCrypt
{

    public BlizzCrypt()
    {
    }

    public static void xorEncryptArray(byte message[], byte key[])
    {
        for(int i = key.length - 1; i >= 0; i--)
            message[i] ^= key[i];

    }

    /**
     * Generates an array of random bytes.
     * 
     * To protect against potentially weak PRNGs of J2ME implementations, 
     * the function first generates random numbers in 64 byte blocks
     * and fills the result array with SHA-160 hashes of these blocks.
     * It should be sufficient for an emulator with a high quality PRNG
     * to leave out the hashing part. 
     * 
     * @param size number of random bytes to be generated
     * @return array of $size random bytes âˆˆ [0..255] 
     */
    public static byte[] genRandomBytes(int size)
    {
        byte result[] = new byte[size];
        Random random = new Random(System.currentTimeMillis());
        HashSHA1 sha_hash = new HashSHA1();
        for(int k = 0; k < size; k += 20)
        {
            int i1 = Math.min(20, size - k);
            byte abyte1[] = new byte[64];
            for(int j1 = 63; j1 >= 0; j1--)
                abyte1[j1] = (byte)(Math.abs(random.nextInt()) % 256);

            sha_hash.initContext();
            sha_hash.updateEngine(abyte1, 0, 64);
            abyte1 = sha_hash.getDigest();
            System.arraycopy(abyte1, 0, result, k, i1);
        }

        return result;
    }

    /**
     * gets called (only) by the Network class for the authenticator registration
     * @param abyte0: array of 55 bytes, generated by {@link Authenticator#generateEnrollmentMash()} 
     */
    public static void prepareEnrollmentBytes(byte abyte0[])
    {
        d = 0;
        byte abyte1[];
        (abyte1 = new byte[abyte0.length + 1])[0] = 1;
        System.arraycopy(abyte0, 0, abyte1, 1, abyte0.length);
        abyte0 = abyte1;
        OTP = new int[32];
        int i = OTP.length - 1;
        for(int k = abyte0.length - 1; k >= 0; k -= 4)
        {
            int x = 0;
            for(int j1 = 3; j1 >= 0; j1--)
                if(k - j1 >= 0)
                    x = (x <<= 8) | abyte0[k - j1] & 0xff;

            OTP[i] = x;
            i--;
        }

    }

    static void intToBytes(int num, byte abyte[], int offset)
    {
        for(int l = offset + 3; l >= offset; l--)
        {
            byte byte0 = (byte)(num & 0xff);
            abyte[l] = byte0;
            num >>>= 8;
        }

    }
    
    public static int round()
    {
        if(d == 0)
        {
            a = new int[33];
            crazyOp(a, OTP, funky_consts_2, funky_consts_1, 0x31d17657L);
        } else
        if(d == 1)
        {
            b = new int[32];
            System.arraycopy(OTP, 0, b, 0, 32);
        } else
        if(d < 10)
            crazyOp(a, OTP, OTP, funky_consts_1, 0x31d17657L);
        else
        if(d == 10)
            crazyOp(a, OTP, b, funky_consts_1, 0x31d17657L);
        else
        if(d == 11)
        {
            setArrayZero(b);
            b[b.length - 1] = 1;
            crazyOp(a, OTP, b, funky_consts_1, 0x31d17657L);
        }
        d++;
        return d;
    }

    public static byte[] getOTPBytes()
    {
        byte abyte0[] = new byte[128];
        for(int i = 0; i < OTP.length; i++)
            intToBytes(OTP[i], abyte0, i * 4);

        return abyte0;
    }

    private static void setArrayZero(int ai[])
    {
        for(int i = 0; i < ai.length; i++)
            ai[i] = 0;

    }

    /**
     * OMG!
     * 
     * @param a1 kittens
     * @param a2 ponies
     * @param a3 unicorns
     * @param a4 pixies
     * @param lfoo hacksaw
     */
    private static void crazyOp(int a1[], int a2[], int a3[], int a4[], long lfoo)
    {
        int i;
        int k = (i = a4.length) - 1;
        long l2 = (long)a3[i - 1] & 0xffffffffL;
        setArrayZero(a1);
        for(int i1 = i; i1 > 0; i1--)
        {
            long l3 = (long)a2[i1 - 1] & 0xffffffffL;
            long l4 = (((long)a1[i] & 0xffffffffL) + (l3 * l2 & 0xffffffffL) & 0xffffffffL) * lfoo & 0xffffffffL;
            long l5 = l3 * l2;
            long l7 = l4 * ((long)a4[i - 1] & 0xffffffffL);
            long l9 = ((long)a1[i] & 0xffffffffL) + (l5 & 0xffffffffL) + (l7 & 0xffffffffL);
            long l11 = (l5 >>> 32) + (l7 >>> 32) + (l9 >>> 32);
            for(int j1 = k; j1 > 0; j1--)
            {
                long l6 = l3 * ((long)a3[j1 - 1] & 0xffffffffL);
                long l8 = l4 * ((long)a4[j1 - 1] & 0xffffffffL);
                long l10 = ((long)a1[j1] & 0xffffffffL) + (l6 & 0xffffffffL) + (l8 & 0xffffffffL) + (l11 & 0xffffffffL);
                l11 = (l11 >>> 32) + (l6 >>> 32) + (l8 >>> 32) + (l10 >>> 32);
                a1[j1 + 1] = (int)l10;
            }

            l11 += (long)a1[0] & 0xffffffffL;
            a1[1] = (int)l11;
            a1[0] = (int)(l11 >>> 32);
            if((i & 3) == 0)
                Thread.yield();
        }

        if(a(a1, a4))
            b(a1, a4);
        System.arraycopy(a1, 1, a2, 0, i);
    }

    private static boolean a(int aint1[], int aint2[])
    {
        if(aint1[0] != 0)
            return true;
        for(int i = 0; i < aint2.length; i++)
        {
            long l1 = (long)aint1[i + 1] & 0xffffffffL;
            long l2 = (long)aint2[i] & 0xffffffffL;
            if(l1 > l2)
                return true;
            if(l2 > l1)
                return false;
        }

        return true;
    }

    private static void b(int aint1[], int aint2[])
    {
        int i = 0;
        for(int k = aint1.length - 1; k >= 1; k--)
        {
            long l1 = (long)aint1[k] & 0xffffffffL;
            long l2 = (long)aint2[k - 1] & 0xffffffffL;
            l1 = (l1 - l2) + (long)i;
            aint1[k] = (int)l1;
            i = (int)(l1 >> 63);
        }

    }

    /**
     * CAUTION! Hungry raptors!
     */
    private static final int funky_consts_1[] = {
        0x955e4bd9, 0x89f3917d, 0x2f15544a, 0x7e0504eb, 0x9d7bb66b, 0x6f8a2fe4, 0x70e453c7, 0x79200e5e, 0x3ad2e43a, 0x02d06c4a, 
        0xdbd8d328, 0xf1a426b8, 0x3658e88b, 0xfd949b2a, 0xf4eaf300, 0x54673a14, 0x19a250fa, 0x4cc1278d, 0x12855b5b, 0x25818d16, 
        0x2c6e6ee2, 0xab4a350d, 0x401d78f6, 0xddb99711, 0xe72626b4, 0x8bd8b5b0, 0xb7f3acf9, 0xea3c9e00, 0x05fee59e, 0x19136cdb, 
        0x7c83f2ab, 0x8b0a2a99
    };
    
    /**
     * "Help! I am trapped in a video game factory!"
     */
    private static final int funky_consts_2[] = {
        0x9403ecf6, 0x24ab7e62, 0xf06bb765, 0xa9a7d8e3, 0x56e338ec, 0xa5e418fa, 0x568d53fa, 0x61d2fa63, 0x6fd56ce5, 0x7f9bdd64, 
        0x7b4fdf6b, 0x0345627f, 0x06ff163c, 0x69e0d8ee, 0xf28532b3, 0x755bec12, 0x26fd4162, 0xa79f1268, 0xcdefce44, 0x4bb0e8f3, 
        0xe3daca30, 0x93e4852b, 0xb7e14266, 0xd5c3e3af, 0x7a33cdde, 0x30b02806, 0x1ff386d5, 0xda74d118, 0xdc065349, 0x743e9227, 
        0x95457c7b, 0x57205fb6
    };
    
    static int a[];
    static int b[];
    static int OTP[];
    static int d = -1;

}